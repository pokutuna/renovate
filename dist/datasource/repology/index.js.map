{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../lib/datasource/repology/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { URLSearchParams } from 'url';\nimport { HOST_DISABLED } from '../../constants/error-messages';\nimport { logger } from '../../logger';\nimport { ExternalHostError } from '../../types/errors/external-host-error';\nimport * as packageCache from '../../util/cache/package';\nimport { Http } from '../../util/http';\nimport { GetReleasesConfig, ReleaseResult } from '../common';\n\nexport const id = 'repology';\n\nconst http = new Http(id);\nconst cacheNamespace = `datasource-${id}`;\nconst cacheMinutes = 60;\n\nexport type RepologyPackageType = 'binname' | 'srcname';\n\nexport interface RepologyPackage {\n  repo: string;\n  visiblename: string;\n  version: string;\n  srcname?: string;\n  binname?: string;\n  origversion?: string;\n}\n\nasync function queryPackage(\n  repoName: string,\n  pkgName: string,\n  pkgType: RepologyPackageType\n): Promise<RepologyPackage> {\n  try {\n    const query = new URLSearchParams({\n      repo: repoName,\n      name_type: pkgType,\n      target_page: 'api_v1_project',\n      noautoresolve: 'on',\n      name: pkgName,\n    }).toString();\n\n    // Retrieve list of packages by looking up Repology project\n    const url = `https://repology.org/tools/project-by?${query}`;\n    const res = await http.getJson<RepologyPackage[]>(url);\n    let pkgs = res.body.filter((pkg) => pkg.repo === repoName);\n\n    // In some cases Repology bundles multiple packages into a single project,\n    // which would result in ambiguous results. If we have more than one result\n    // left, we should try to determine the correct package by comparing either\n    // binname or srcname (depending on pkgType) to the given dependency name.\n    if (pkgs.length > 1) {\n      pkgs = pkgs.filter((pkg) => !pkg[pkgType] || pkg[pkgType] === pkgName);\n    }\n\n    // Abort if there is still more than one package left, as the result would\n    // be ambiguous and unreliable. This should usually not happen...\n    if (pkgs.length > 1) {\n      logger.warn(\n        { repoName, pkgName, pkgType, pkgs },\n        'Repology lookup returned ambiguous results, ignoring...'\n      );\n      return null;\n    }\n\n    return pkgs[0];\n  } catch (err) {\n    if (err.statusCode === 404) {\n      logger.debug(\n        { repoName, pkgName, pkgType },\n        'Repository or package not found on Repology'\n      );\n    } else if (err.statusCode === 403) {\n      logger.debug(\n        { repoName },\n        'Repology does not support tools/project-by lookups for repository'\n      );\n    } else {\n      throw err;\n    }\n  }\n\n  return null;\n}\n\nasync function getCachedPackage(\n  repoName: string,\n  pkgName: string\n): Promise<RepologyPackage> {\n  // Fetch previous result from cache if available\n  const cacheKey = `${repoName}/${pkgName}`;\n  const cachedResult = await packageCache.get<RepologyPackage>(\n    cacheNamespace,\n    cacheKey\n  );\n  // istanbul ignore if\n  if (cachedResult) {\n    return cachedResult;\n  }\n\n  // Attempt a binary package lookup and return if successfully\n  const binPkg = await queryPackage(repoName, pkgName, 'binname');\n  if (binPkg) {\n    await packageCache.set(cacheNamespace, cacheKey, binPkg, cacheMinutes);\n    return binPkg;\n  }\n\n  // Otherwise, attempt a source package lookup and return if successfully\n  const srcPkg = await queryPackage(repoName, pkgName, 'srcname');\n  if (srcPkg) {\n    await packageCache.set(cacheNamespace, cacheKey, srcPkg, cacheMinutes);\n    return srcPkg;\n  }\n\n  // No binary or source package was found on Repology\n  return null;\n}\n\nexport async function getReleases({\n  lookupName,\n}: GetReleasesConfig): Promise<ReleaseResult | null> {\n  // Ensure lookup name contains both repository and package\n  const [repoName, pkgName] = lookupName.split('/', 2);\n  if (!repoName || !pkgName) {\n    throw new ExternalHostError(\n      new Error(\n        'Repology lookup name must contain repository and package separated by slash (<repo>/<pkg>)'\n      )\n    );\n  }\n\n  // Attempt to resolve package version through Repology\n  logger.trace(`repology.getReleases(${repoName}, ${pkgName})`);\n  try {\n    // Attempt to retrieve (cached) package information from Repology\n    const pkg = await getCachedPackage(repoName, pkgName);\n    if (!pkg) {\n      return null;\n    }\n\n    // Always prefer origversion if available, otherwise default to version\n    // This is required as source packages usually have no origversion\n    const version = pkg.origversion ?? pkg.version;\n    return { releases: [{ version }] };\n  } catch (err) {\n    if (err.message === HOST_DISABLED) {\n      // istanbul ignore next\n      logger.trace({ lookupName, err }, 'Host disabled');\n    } else {\n      logger.warn(\n        { lookupName, err },\n        'Repology lookup failed with unexpected error'\n      );\n    }\n\n    throw new ExternalHostError(err);\n  }\n}\n"]}