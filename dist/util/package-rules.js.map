{"version":3,"file":"package-rules.js","sourceRoot":"","sources":["../../lib/util/package-rules.ts"],"names":[],"mappings":"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","sourcesContent":["import minimatch from 'minimatch';\nimport { PackageRule, UpdateType, mergeChildConfig } from '../config';\nimport { logger } from '../logger';\nimport * as allVersioning from '../versioning';\nimport { regEx } from './regex';\n\n// TODO: move to `../config`\nexport interface Config extends Record<string, any> {\n  versioning?: string;\n  packageFile?: string;\n  depType?: string;\n  depTypes?: string[];\n  depName?: string;\n  currentValue?: string;\n  fromVersion?: string;\n  lockedVersion?: string;\n  updateType?: UpdateType;\n  isBump?: boolean;\n  sourceUrl?: string;\n  language?: string;\n  baseBranch?: string;\n  manager?: string;\n  datasource?: string;\n  packageRules?: (PackageRule & Config)[];\n}\n\nfunction matchesRule(inputConfig: Config, packageRule: PackageRule): boolean {\n  const {\n    versioning,\n    packageFile,\n    depType,\n    depTypes,\n    depName,\n    currentValue,\n    fromVersion,\n    lockedVersion,\n    updateType,\n    isBump,\n    sourceUrl,\n    language,\n    baseBranch,\n    manager,\n    datasource,\n  } = inputConfig;\n  let {\n    paths,\n    languages,\n    baseBranchList,\n    managers,\n    datasources,\n    depTypeList,\n    packageNames,\n    packagePatterns,\n    excludePackageNames,\n    excludePackagePatterns,\n    matchCurrentVersion,\n    sourceUrlPrefixes,\n    updateTypes,\n  } = packageRule;\n  // Setting empty arrays simplifies our logic later\n  paths = paths || [];\n  languages = languages || [];\n  baseBranchList = baseBranchList || [];\n  managers = managers || [];\n  datasources = datasources || [];\n  depTypeList = depTypeList || [];\n  packageNames = packageNames || [];\n  packagePatterns = packagePatterns || [];\n  excludePackageNames = excludePackageNames || [];\n  excludePackagePatterns = excludePackagePatterns || [];\n  sourceUrlPrefixes = sourceUrlPrefixes || [];\n  matchCurrentVersion = matchCurrentVersion || null;\n  updateTypes = updateTypes || [];\n  let positiveMatch = false;\n  // Massage a positive patterns patch if an exclude one is present\n  if (\n    (excludePackageNames.length || excludePackagePatterns.length) &&\n    !(packageNames.length || packagePatterns.length)\n  ) {\n    packagePatterns = ['.*'];\n  }\n  if (paths.length) {\n    const isMatch = paths.some(\n      (rulePath) =>\n        packageFile.includes(rulePath) ||\n        minimatch(packageFile, rulePath, { dot: true })\n    );\n    if (!isMatch) {\n      return false;\n    }\n    positiveMatch = true;\n  }\n  if (depTypeList.length) {\n    const isMatch =\n      depTypeList.includes(depType) ||\n      depTypes?.some((dt) => depTypeList.includes(dt));\n    if (!isMatch) {\n      return false;\n    }\n    positiveMatch = true;\n  }\n  if (languages.length) {\n    const isMatch = languages.includes(language);\n    if (!isMatch) {\n      return false;\n    }\n    positiveMatch = true;\n  }\n  if (baseBranchList.length) {\n    const isMatch = baseBranchList.includes(baseBranch);\n    if (!isMatch) {\n      return false;\n    }\n    positiveMatch = true;\n  }\n  if (managers.length) {\n    const isMatch = managers.includes(manager);\n    if (!isMatch) {\n      return false;\n    }\n    positiveMatch = true;\n  }\n  if (datasources.length) {\n    const isMatch = datasources.includes(datasource);\n    if (!isMatch) {\n      return false;\n    }\n    positiveMatch = true;\n  }\n  if (updateTypes.length) {\n    const isMatch =\n      updateTypes.includes(updateType) ||\n      (isBump && updateTypes.includes('bump'));\n    if (!isMatch) {\n      return false;\n    }\n    positiveMatch = true;\n  }\n  if (packageNames.length || packagePatterns.length) {\n    let isMatch = packageNames.includes(depName);\n    // name match is \"or\" so we check patterns if we didn't match names\n    if (!isMatch) {\n      for (const packagePattern of packagePatterns) {\n        const packageRegex = regEx(\n          packagePattern === '^*$' || packagePattern === '*'\n            ? '.*'\n            : packagePattern\n        );\n        if (packageRegex.test(depName)) {\n          logger.trace(`${depName} matches against ${packageRegex}`);\n          isMatch = true;\n        }\n      }\n    }\n    if (!isMatch) {\n      return false;\n    }\n    positiveMatch = true;\n  }\n  if (excludePackageNames.length) {\n    const isMatch = excludePackageNames.includes(depName);\n    if (isMatch) {\n      return false;\n    }\n    positiveMatch = true;\n  }\n  if (excludePackagePatterns.length) {\n    let isMatch = false;\n    for (const pattern of excludePackagePatterns) {\n      const packageRegex = regEx(\n        pattern === '^*$' || pattern === '*' ? '.*' : pattern\n      );\n      if (packageRegex.test(depName)) {\n        logger.trace(`${depName} matches against ${packageRegex}`);\n        isMatch = true;\n      }\n    }\n    if (isMatch) {\n      return false;\n    }\n    positiveMatch = true;\n  }\n  if (sourceUrlPrefixes.length) {\n    const isMatch = sourceUrlPrefixes.some((prefix) =>\n      sourceUrl?.startsWith(prefix)\n    );\n    if (!isMatch) {\n      return false;\n    }\n    positiveMatch = true;\n  }\n  if (matchCurrentVersion) {\n    const version = allVersioning.get(versioning);\n    const matchCurrentVersionStr = matchCurrentVersion.toString();\n    if (version.isVersion(matchCurrentVersionStr)) {\n      let isMatch = false;\n      try {\n        isMatch = version.matches(matchCurrentVersionStr, currentValue);\n      } catch (err) {\n        // Do nothing\n      }\n      if (!isMatch) {\n        return false;\n      }\n      positiveMatch = true;\n    } else {\n      const compareVersion =\n        currentValue && version.isVersion(currentValue)\n          ? currentValue // it's a version so we can match against it\n          : lockedVersion || fromVersion; // need to match against this fromVersion, if available\n      if (compareVersion) {\n        // istanbul ignore next\n        if (version.isVersion(compareVersion)) {\n          const isMatch = version.matches(compareVersion, matchCurrentVersion);\n          // istanbul ignore if\n          if (!isMatch) {\n            return false;\n          }\n          positiveMatch = true;\n        } else {\n          return false;\n        }\n      } else {\n        logger.debug(\n          { matchCurrentVersionStr, currentValue },\n          'Could not find a version to compare'\n        );\n        return false;\n      }\n    }\n  }\n  return positiveMatch;\n}\n\nexport function applyPackageRules<T extends Config>(inputConfig: T): T {\n  let config = { ...inputConfig };\n  const packageRules = config.packageRules || [];\n  logger.trace(\n    { dependency: config.depName, packageRules },\n    `Checking against ${packageRules.length} packageRules`\n  );\n  packageRules.forEach((packageRule) => {\n    // This rule is considered matched if there was at least one positive match and no negative matches\n    if (matchesRule(config, packageRule)) {\n      // Package rule config overrides any existing config\n      config = mergeChildConfig(config, packageRule);\n      delete config.packageNames;\n      delete config.packagePatterns;\n      delete config.excludePackageNames;\n      delete config.excludePackagePatterns;\n      delete config.depTypeList;\n      delete config.matchCurrentVersion;\n    }\n  });\n  return config;\n}\n"]}