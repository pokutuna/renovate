{"version":3,"file":"range.js","sourceRoot":"","sources":["../../../lib/versioning/pep440/range.ts"],"names":[],"mappings":"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","sourcesContent":["import { gte, lte, satisfies } from '@renovate/pep440';\nimport { parse as parseRange } from '@renovate/pep440/lib/specifier';\nimport { parse as parseVersion } from '@renovate/pep440/lib/version';\nimport { logger } from '../../logger';\nimport { NewValueConfig } from '../common';\n\nfunction getFutureVersion(\n  baseVersion: string,\n  toVersion: string,\n  step: number\n): string {\n  const toRelease: number[] = parseVersion(toVersion).release;\n  const baseRelease: number[] = parseVersion(baseVersion).release;\n  let found = false;\n  const futureRelease = baseRelease.map((basePart, index) => {\n    if (found) {\n      return 0;\n    }\n    const toPart = toRelease[index] || 0;\n    if (toPart > basePart) {\n      found = true;\n      return toPart + step;\n    }\n    return toPart;\n  });\n  if (!found) {\n    futureRelease[futureRelease.length - 1] += step;\n  }\n  return futureRelease.join('.');\n}\n\ninterface Range {\n  operator: string;\n  prefix: string;\n  version: string;\n}\n\nexport function getNewValue({\n  currentValue,\n  rangeStrategy,\n  fromVersion,\n  toVersion,\n}: NewValueConfig): string {\n  // easy pin\n  if (rangeStrategy === 'pin') {\n    return '==' + toVersion;\n  }\n  if (currentValue === fromVersion) {\n    return toVersion;\n  }\n  const ranges: Range[] = parseRange(currentValue);\n  if (!ranges) {\n    logger.warn('Invalid currentValue: ' + currentValue);\n    return null;\n  }\n  if (!ranges.length) {\n    // an empty string is an allowed value for PEP440 range\n    // it means get any version\n    logger.warn('Empty currentValue: ' + currentValue);\n    return currentValue;\n  }\n  if (rangeStrategy === 'replace') {\n    if (satisfies(toVersion, currentValue)) {\n      return currentValue;\n    }\n  }\n  if (!['replace', 'bump'].includes(rangeStrategy)) {\n    logger.debug(\n      'Unsupported rangeStrategy: ' +\n        rangeStrategy +\n        '. Using \"replace\" instead.'\n    );\n    return getNewValue({\n      currentValue,\n      rangeStrategy: 'replace',\n      fromVersion,\n      toVersion,\n    });\n  }\n  if (ranges.some((range) => range.operator === '===')) {\n    // the operator \"===\" is used for legacy non PEP440 versions\n    logger.warn('Arbitrary equality not supported: ' + currentValue);\n    return null;\n  }\n  let result = ranges\n    .map((range) => {\n      // used to exclude versions,\n      // we assume that's for a good reason\n      if (range.operator === '!=') {\n        return range.operator + range.version;\n      }\n\n      // used to mark minimum supported version\n      if (['>', '>='].includes(range.operator)) {\n        if (lte(toVersion, range.version)) {\n          // this looks like a rollback\n          return '>=' + toVersion;\n        }\n        // this is similar to ~=\n        if (rangeStrategy === 'bump' && range.operator === '>=') {\n          return range.operator + toVersion;\n        }\n        // otherwise treat it same as exclude\n        return range.operator + range.version;\n      }\n\n      // this is used to exclude future versions\n      if (range.operator === '<') {\n        // if toVersion is that future version\n        if (gte(toVersion, range.version)) {\n          // now here things get tricky\n          // we calculate the new future version\n          const futureVersion = getFutureVersion(range.version, toVersion, 1);\n          return range.operator + futureVersion;\n        }\n        // otherwise treat it same as exclude\n        return range.operator + range.version;\n      }\n\n      // keep the .* suffix\n      if (range.prefix) {\n        const futureVersion = getFutureVersion(range.version, toVersion, 0);\n        return range.operator + futureVersion + '.*';\n      }\n\n      if (['==', '~=', '<='].includes(range.operator)) {\n        return range.operator + toVersion;\n      }\n\n      // unless PEP440 changes, this won't happen\n      // istanbul ignore next\n      logger.error(\n        { toVersion, currentValue, range },\n        'pep440: failed to process range'\n      );\n      // istanbul ignore next\n      return null;\n    })\n    .filter(Boolean)\n    .join(', ');\n\n  if (result.includes(', ') && !currentValue.includes(', ')) {\n    result = result.replace(/, /g, ',');\n  }\n\n  if (!satisfies(toVersion, result)) {\n    // we failed at creating the range\n    logger.error(\n      { result, toVersion, currentValue },\n      'pep440: failed to calcuate newValue'\n    );\n    return null;\n  }\n\n  return result;\n}\n"]}