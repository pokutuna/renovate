"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.detectVulnerabilityAlerts = void 0;
const error_messages_1 = require("../../../constants/error-messages");
const datasourceMaven = __importStar(require("../../../datasource/maven"));
const datasourceNpm = __importStar(require("../../../datasource/npm"));
const datasourceNuget = __importStar(require("../../../datasource/nuget"));
const datasourcePypi = __importStar(require("../../../datasource/pypi"));
const datasourceRubygems = __importStar(require("../../../datasource/rubygems"));
const logger_1 = require("../../../logger");
const platform_1 = require("../../../platform");
const allVersioning = __importStar(require("../../../versioning"));
const mavenVersioning = __importStar(require("../../../versioning/maven"));
const npmVersioning = __importStar(require("../../../versioning/npm"));
const pep440Versioning = __importStar(require("../../../versioning/pep440"));
const rubyVersioning = __importStar(require("../../../versioning/ruby"));
const semverVersioning = __importStar(require("../../../versioning/semver"));
async function detectVulnerabilityAlerts(input) {
    if (!(input === null || input === void 0 ? void 0 : input.vulnerabilityAlerts)) {
        return input;
    }
    if (input.vulnerabilityAlerts.enabled === false) {
        logger_1.logger.debug('Vulnerability alerts are disabled');
        return input;
    }
    const alerts = await platform_1.platform.getVulnerabilityAlerts();
    if (!alerts.length) {
        logger_1.logger.debug('No vulnerability alerts found');
        if (input.vulnerabilityAlertsOnly) {
            throw new Error(error_messages_1.REPOSITORY_NO_VULNERABILITY);
        }
        return input;
    }
    const config = { ...input };
    const combinedAlerts = {};
    for (const alert of alerts) {
        try {
            if (alert.dismissReason) {
                continue; // eslint-disable-line no-continue
            }
            if (!alert.securityVulnerability.firstPatchedVersion) {
                logger_1.logger.debug({ alert }, 'Vulnerability alert has no firstPatchedVersion - skipping');
                continue; // eslint-disable-line no-continue
            }
            const datasourceMapping = {
                MAVEN: datasourceMaven.id,
                NPM: datasourceNpm.id,
                NUGET: datasourceNuget.id,
                PIP: datasourcePypi.id,
                RUBYGEMS: datasourceRubygems.id,
            };
            const datasource = datasourceMapping[alert.securityVulnerability.package.ecosystem];
            if (!combinedAlerts[datasource]) {
                combinedAlerts[datasource] = {};
            }
            const depName = alert.securityVulnerability.package.name;
            if (!combinedAlerts[datasource][depName]) {
                combinedAlerts[datasource][depName] = {
                    advisories: [],
                    fileNames: [],
                };
            }
            combinedAlerts[datasource][depName].advisories.push(alert.securityAdvisory);
            const fileName = alert.vulnerableManifestFilename;
            if (!combinedAlerts[datasource][depName].fileNames.includes(fileName)) {
                combinedAlerts[datasource][depName].fileNames.push(fileName);
            }
            const firstPatchedVersion = alert.securityVulnerability.firstPatchedVersion.identifier;
            const versionings = {
                maven: mavenVersioning.id,
                npm: npmVersioning.id,
                nuget: semverVersioning.id,
                pip_requirements: pep440Versioning.id,
                rubygems: rubyVersioning.id,
            };
            const version = allVersioning.get(versionings[datasource]);
            if (version.isVersion(firstPatchedVersion)) {
                if (combinedAlerts[datasource][depName].firstPatchedVersion) {
                    if (version.isGreaterThan(firstPatchedVersion, combinedAlerts[datasource][depName].firstPatchedVersion)) {
                        combinedAlerts[datasource][depName].firstPatchedVersion = firstPatchedVersion;
                        combinedAlerts[datasource][depName].vulnerableRequirements =
                            alert.vulnerableRequirements;
                    }
                }
                else {
                    combinedAlerts[datasource][depName].firstPatchedVersion = firstPatchedVersion;
                    combinedAlerts[datasource][depName].vulnerableRequirements =
                        alert.vulnerableRequirements;
                }
            }
            else {
                logger_1.logger.debug('Invalid firstPatchedVersion: ' + firstPatchedVersion);
            }
        }
        catch (err) {
            logger_1.logger.warn({ err }, 'Error parsing vulnerability alert');
        }
    }
    const alertPackageRules = [];
    for (const [datasource, dependencies] of Object.entries(combinedAlerts)) {
        for (const [depName, val] of Object.entries(dependencies)) {
            let prBodyNotes = [];
            try {
                prBodyNotes = ['### GitHub Vulnerability Alerts'].concat(val.advisories.map((advisory) => {
                    let content = '#### ';
                    let heading;
                    if (advisory.identifiers.some((id) => id.type === 'CVE')) {
                        heading = advisory.identifiers
                            .filter((id) => id.type === 'CVE')
                            .map((id) => id.value)
                            .join(' / ');
                    }
                    else {
                        heading = advisory.identifiers.map((id) => id.value).join(' / ');
                    }
                    if (advisory.references.length) {
                        heading = `[${heading}](${advisory.references[0].url})`;
                    }
                    content += heading;
                    content += '\n\n';
                    content += advisory.description;
                    return content;
                }));
            }
            catch (err) /* istanbul ignore next */ {
                logger_1.logger.warn({ err }, 'Error generating vulnerability PR notes');
            }
            let matchCurrentVersion = val.vulnerableRequirements;
            // istanbul ignore if
            if (!matchCurrentVersion) {
                if (datasource === datasourceMaven.id) {
                    matchCurrentVersion = `(,${val.firstPatchedVersion})`;
                }
                else {
                    matchCurrentVersion = `< ${val.firstPatchedVersion}`;
                }
            }
            const allowedVersions = datasource === datasourcePypi.id
                ? `==${val.firstPatchedVersion}`
                : val.firstPatchedVersion;
            const matchRule = {
                datasources: [datasource],
                packageNames: [depName],
                matchCurrentVersion,
                allowedVersions,
                prBodyNotes,
                force: {
                    ...config.vulnerabilityAlerts,
                    vulnerabilityAlert: true,
                    branchTopic: `${datasource}-${depName}-vulnerability`,
                },
            };
            alertPackageRules.push(matchRule);
        }
    }
    logger_1.logger.debug({ alertPackageRules }, 'alert package rules');
    config.packageRules = (config.packageRules || []).concat(alertPackageRules);
    return config;
}
exports.detectVulnerabilityAlerts = detectVulnerabilityAlerts;
//# sourceMappingURL=vulnerability.js.map