{"version":3,"file":"get-updated.js","sourceRoot":"","sources":["../../../lib/workers/branch/get-updated.ts"],"names":[],"mappings":"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","sourcesContent":["import is from '@sindresorhus/is';\nimport { WORKER_FILE_UPDATE_FAILED } from '../../constants/error-messages';\nimport * as datasourceGitSubmodules from '../../datasource/git-submodules';\nimport { logger } from '../../logger';\nimport { get } from '../../manager';\nimport { ArtifactError } from '../../manager/common';\nimport { File, getFile } from '../../util/git';\nimport { BranchConfig } from '../common';\nimport { doAutoReplace } from './auto-replace';\n\nexport interface PackageFilesResult {\n  artifactErrors: ArtifactError[];\n  reuseExistingBranch?: boolean;\n  updatedPackageFiles: File[];\n  updatedArtifacts: File[];\n}\n\nexport async function getUpdatedPackageFiles(\n  config: BranchConfig\n): Promise<PackageFilesResult> {\n  logger.trace({ config });\n  const { branchName, reuseExistingBranch } = config;\n  logger.debug(\n    { reuseExistingBranch, branchName },\n    'manager.getUpdatedPackageFiles()'\n  );\n  const updatedFileContents: Record<string, string> = {};\n  const packageFileManagers: Record<string, string> = {};\n  const packageFileUpdatedDeps: Record<string, string[]> = {};\n  const lockFileMaintenanceFiles = [];\n  for (const upgrade of config.upgrades) {\n    const { manager, packageFile, depName } = upgrade;\n    packageFileManagers[packageFile] = manager;\n    packageFileUpdatedDeps[packageFile] =\n      packageFileUpdatedDeps[packageFile] || [];\n    packageFileUpdatedDeps[packageFile].push(depName);\n    if (upgrade.updateType === 'lockFileMaintenance') {\n      lockFileMaintenanceFiles.push(packageFile);\n    } else {\n      let existingContent = updatedFileContents[packageFile];\n      if (!existingContent) {\n        existingContent = await getFile(\n          packageFile,\n          reuseExistingBranch ? config.branchName : config.baseBranch\n        );\n      }\n      // istanbul ignore if\n      if (config.reuseExistingBranch && !existingContent) {\n        logger.debug(\n          { packageFile, depName },\n          'Rebasing branch after file not found'\n        );\n        return getUpdatedPackageFiles({\n          ...config,\n          reuseExistingBranch: false,\n        });\n      }\n      const updateDependency = get(manager, 'updateDependency');\n      if (!updateDependency) {\n        const res = await doAutoReplace(\n          upgrade,\n          existingContent,\n          reuseExistingBranch\n        );\n        if (res) {\n          if (res === existingContent) {\n            logger.debug({ packageFile, depName }, 'No content changed');\n          } else {\n            logger.debug({ packageFile, depName }, 'Contents updated');\n            updatedFileContents[packageFile] = res;\n          }\n          continue; // eslint-disable-line no-continue\n        } else if (reuseExistingBranch) {\n          return getUpdatedPackageFiles({\n            ...config,\n            reuseExistingBranch: false,\n          });\n        }\n        logger.error({ packageFile, depName }, 'Could not autoReplace');\n        throw new Error(WORKER_FILE_UPDATE_FAILED);\n      }\n      const newContent = await updateDependency({\n        fileContent: existingContent,\n        upgrade,\n      });\n      if (!newContent) {\n        if (config.reuseExistingBranch) {\n          logger.debug(\n            { packageFile, depName },\n            'Rebasing branch after error updating content'\n          );\n          return getUpdatedPackageFiles({\n            ...config,\n            reuseExistingBranch: false,\n          });\n        }\n        logger.debug(\n          { existingContent, config: upgrade },\n          'Error updating file'\n        );\n        throw new Error(WORKER_FILE_UPDATE_FAILED);\n      }\n      if (newContent !== existingContent) {\n        if (config.reuseExistingBranch) {\n          // This ensure it's always 1 commit from the bot\n          logger.debug(\n            { packageFile, depName },\n            'Need to update package file so will rebase first'\n          );\n          return getUpdatedPackageFiles({\n            ...config,\n            reuseExistingBranch: false,\n          });\n        }\n        logger.debug({ packageFile, depName }, 'Updating packageFile content');\n        updatedFileContents[packageFile] = newContent;\n      }\n      if (\n        newContent === existingContent &&\n        upgrade.datasource === datasourceGitSubmodules.id\n      ) {\n        updatedFileContents[packageFile] = newContent;\n      }\n    }\n  }\n  const updatedPackageFiles = Object.keys(updatedFileContents).map((name) => ({\n    name,\n    contents: updatedFileContents[name],\n  }));\n  const updatedArtifacts: File[] = [];\n  const artifactErrors: ArtifactError[] = [];\n  for (const packageFile of updatedPackageFiles) {\n    const manager = packageFileManagers[packageFile.name];\n    const updatedDeps = packageFileUpdatedDeps[packageFile.name];\n    const updateArtifacts = get(manager, 'updateArtifacts');\n    if (updateArtifacts) {\n      const results = await updateArtifacts({\n        packageFileName: packageFile.name,\n        updatedDeps,\n        newPackageFileContent: packageFile.contents,\n        config,\n      });\n      if (is.nonEmptyArray(results)) {\n        for (const res of results) {\n          const { file, artifactError } = res;\n          if (file) {\n            updatedArtifacts.push(file);\n          } else if (artifactError) {\n            artifactErrors.push(artifactError);\n          }\n        }\n      }\n    }\n  }\n  if (!config.reuseExistingBranch) {\n    // Only perform lock file maintenance if it's a fresh commit\n    for (const packageFile of lockFileMaintenanceFiles) {\n      const manager = packageFileManagers[packageFile];\n      const updateArtifacts = get(manager, 'updateArtifacts');\n      if (updateArtifacts) {\n        const packageFileContents =\n          updatedFileContents[packageFile] ||\n          (await getFile(\n            packageFile,\n            config.reuseExistingBranch ? config.branchName : config.baseBranch\n          ));\n        const results = await updateArtifacts({\n          packageFileName: packageFile,\n          updatedDeps: [],\n          newPackageFileContent: packageFileContents,\n          config,\n        });\n        if (is.nonEmptyArray(results)) {\n          for (const res of results) {\n            const { file, artifactError } = res;\n            if (file) {\n              updatedArtifacts.push(file);\n            } else if (artifactError) {\n              artifactErrors.push(artifactError);\n            }\n          }\n        }\n      }\n    }\n  }\n  return {\n    reuseExistingBranch: config.reuseExistingBranch, // Need to overwrite original config\n    updatedPackageFiles,\n    updatedArtifacts,\n    artifactErrors,\n  };\n}\n"]}